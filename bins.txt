-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Aggregate continuous values into discrete bins
--   
--   Please see the README on GitHub at
--   <a>https://github.com/mstksg/bins#readme</a>
@package bins
@version 0.1.3.0


-- | Tools for aggregating numeric values into a set of discrete bins
--   according to some binning specification.
--   
--   See <a>withBinner</a> for main usage information, and <a>Bin</a> for
--   the main binned data type, and <a>binFreq</a> for a common usage
--   example.
module Data.Bin

-- | Specification of binning.
--   
--   A <tt><a>BinSpec</a> n a b</tt> will bin values of type <tt>a</tt>
--   into <tt>n</tt> bins, according to a scaling in type <tt>b</tt>.
--   
--   Constructor is meant to be used with type application syntax to
--   indicate <tt>n</tt>, like <tt><a>BinSpec</a> </tt>5 0 10
--   <a>linView</a>@
data BinSpec (n :: Nat) a b
BS :: a -> a -> BinView a b -> BinSpec (n :: Nat) a b

-- | lower bound of values
[bsMin] :: BinSpec (n :: Nat) a b -> a

-- | upper bound of values
[bsMax] :: BinSpec (n :: Nat) a b -> a

-- | binning view
[bsView] :: BinSpec (n :: Nat) a b -> BinView a b

-- | Convenient constructor for a <a>BinSpec</a> for a linear scaling.
--   
--   Meant to be used with type application syntax:
--   
--   <pre>
--   <a>linBS</a> @5 0 10
--   </pre>
linBS :: forall n a. () => a -> a -> BinSpec n a a

-- | Convenient constructor for a <a>BinSpec</a> for a logarithmic scaling.
--   
--   Meant to be used with type application syntax:
--   
--   <pre>
--   <a>logBS</a> @5 0 10
--   </pre>
logBS :: forall n a. Floating a => a -> a -> BinSpec n a a

-- | Convenient constructor for a <a>BinSpec</a> for a gaussian scaling.
--   Uses the midpoint as the inferred mean.
--   
--   Meant to be used with type application syntax:
--   
--   <pre>
--   <a>gaussBS</a> @5 3 0 10
--   </pre>
--   
--   indicates that you want 5 bins.
gaussBS :: forall n a. RealFrac a => a -> a -> a -> BinSpec n a Double

-- | A bidirectional "view" to transform the data type before binning.
--   
--   See <a>linView</a> for a linear binning, and <a>logView</a> for a
--   logarithmic binning. You can construct your own custom transformer
--   using <a>binView</a>.
--   
--   This type is essentially <tt>Iso</tt> from the <i>lens</i> library,
--   and any <tt>Iso'</tt> from lens can be used here. However, it is
--   important that all of these represent <i>monotonic</i> isomorphisms.
type BinView a b = forall p. Profunctor p => p b b -> p a a

-- | Construct a <a>BinView</a> based on "to" and "from" functions
--   
--   It is important that the "to" and "from" functions be <i>inverses</i>
--   of each other. Furthermore, both "to" and "from" should be
--   <b>monotonic</b>.
binView :: (a -> b) -> (b -> a) -> BinView a b

-- | Linear binning
linView :: BinView a a

-- | Logarithmic binning (smaller bins at lower levels, larger bins at
--   higher levels).
logView :: Floating a => BinView a a

-- | Binning based on a Gaussian Distribution. Bins "by standard
--   deviation"; there are more bins the closer to the mean you get, and
--   less bins the farther away.
gaussView :: RealFrac a => a -> a -> BinView a Double

-- | Generate a vector of the boundaries deriving the bins from a
--   <a>BinSpec</a>. Can be useful for debugging.
binSpecIntervals :: forall n a b. (KnownNat n, Fractional b) => BinSpec n a b -> Vector (n + 1) a

-- | Generate a vector of the scaled centers of each bin derived from a
--   <a>BinSpec</a>. Can be useful for debugging.
--   
--   Note that for non-linear scales, this centering respects the scale.
--   For example, for logarithmic scales, this is a "log-aware" center: it
--   gives the midpoint in log-space, not linear-space.
binSpecCenters :: forall n a b. (KnownNat n, Fractional b) => BinSpec n a b -> Vector n a

-- | A <tt><a>Bin</a> s n</tt> is a single bin index out of <tt>n</tt>
--   partitions of the original data set, according to a <a>BinSpec</a>
--   represented by <tt>s</tt>.
--   
--   All <a>Bin</a>s with the same <tt>s</tt> follow the same
--   <a>BinSpec</a>, so you can safely use <a>binRange</a>
--   <a>withBinner</a>.
--   
--   It has useful <a>Eq</a> and <a>Ord</a> instances.
--   
--   Actually has <tt>n + 2</tt> partitions, since it also distinguishes
--   values that are outside the <a>BinSpec</a> range.
data Bin s n

-- | The type of a "binning function", given by <a>withBinner</a>. See
--   <a>withBinner</a> for information on how to use.
type Binner s n a = a -> Bin s n

-- | With a <a>BinSpec</a>, give a "binning function" that you can use to
--   create bins within a continuation.
--   
--   <pre>
--   <a>withBinner</a> myBinSpec $ toBin -&gt;
--       show (toBin 2.8523)
--   </pre>
--   
--   Uses a Rank-N continution to ensure that you can only compare
--   <a>Bin</a>s constructed from the same <a>BinSpec</a>/binning function.
withBinner :: (KnownNat n, RealFrac b) => BinSpec n a b -> (forall s. Reifies s (BinSpec n a b) => Binner s n a -> r) -> r

-- | Construct a <a>Bin</a> if you know the bin number you want to specify.
--   See <a>fromIx</a> if you want to specify bins that are over or under
--   the maximum, as well.
fromFin :: Finite n -> Bin s n

-- | Extract, potentially, the <a>Bin</a> index. Will return <a>Nothing</a>
--   if the original value was outside the <a>BinSpec</a> range.
--   
--   See <a>binIx</a> for a more specific version, which indicates if the
--   original value was too high or too low. Also see <a>binFinExt</a>,
--   which extends the range of the <a>Finite</a> to embed lower or higher
--   values.
binFin :: Bin s n -> Maybe (Finite n)

-- | Extract the minimum and maximum of the range indicabed by a given
--   <a>Bin</a>.
--   
--   A <a>Nothing</a> value indicates that we are outside of the normal
--   range of the <a>BinSpec</a>, so is "unbounded" in that direction.
binRange :: forall n a b s. (KnownNat n, Fractional b, Reifies s (BinSpec n a b)) => Bin s n -> (Maybe a, Maybe a)

-- | Extract the minimum of the range indicabed by a given <a>Bin</a>.
--   
--   A <a>Nothing</a> value means that the original value was below the
--   minimum limit of the <a>BinSpec</a>, so is "unbounded" in the lower
--   direction.
binMin :: forall n a b s. (KnownNat n, Fractional b, Reifies s (BinSpec n a b)) => Bin s n -> Maybe a

-- | Extract the maximum of the range indicabed by a given <a>Bin</a>.
--   
--   A <a>Nothing</a> value means that the original value was above the
--   maximum limit of the <a>BinSpec</a>, so is "unbounded" in the upper
--   direction.
binMax :: forall n a b s. (KnownNat n, Fractional b, Reifies s (BinSpec n a b)) => Bin s n -> Maybe a

-- | Extract the center of the range indicabed by a given <a>Bin</a>.
--   
--   A <a>Nothing</a> value means that the original value was either below
--   or above the maximum limit of the <a>BinSpec</a>.
--   
--   Note that for non-linear scales, this centering respects the scale.
--   For example, for logarithmic scales, this is a "log-aware" center: it
--   gives the midpoint in log-space, not linear-space.
binMid :: forall n a b s. (KnownNat n, Fractional b, Reifies s (BinSpec n a b)) => Bin s n -> Maybe a

-- | Like <a>binFin</a>, but return the true "n + 2" slot number of a
--   <a>Bin</a>, where <a>minBound</a> is "below minimum" and
--   <a>maxBound</a> is "above maximum"
binFinExt :: KnownNat n => Bin s n -> Finite ((1 + n) + 1)

-- | Like <a>binFin</a>, but squishes or compresses "below minimum" to
--   "above maximum" bins into the <a>Finite</a>, counting them in the same
--   bin as the minimum and maximum bin, respectively.
binFinComp :: KnownNat n => Bin s n -> Finite n

-- | Display the interval maintained by a <a>Bin</a>.
displayBin :: forall n a b s. (KnownNat n, Fractional b, Reifies s (BinSpec n a b)) => (a -> String) -> Bin s n -> String

-- | Display the interval maintained by a <a>Bin</a>, if the <a>Bin</a>
--   contains a <a>Double</a>.
displayBinDouble :: forall n b s. (KnownNat n, Fractional b, Reifies s (BinSpec n Double b)) => Int -> Bin s n -> String

-- | Data type extending a value with an extra "minimum" and "maximum"
--   value.
data Pointed a
Bot :: Pointed a
PElem :: !a -> Pointed a
Top :: Pointed a

-- | Church-style deconstructor for <a>Pointed</a>, analogous to
--   <a>maybe</a>, <a>either</a>, and <tt>bool</tt>.
pointed :: b -> (a -> b) -> b -> Pointed a -> b

-- | Extract the item from a <a>Pointed</a> if it is neither the extra
--   minimum or maximum.
pElem :: Pointed a -> Maybe a

-- | A more specific version of <a>binFin</a> that indicates whether or not
--   the value was too high or too low for the <a>BinSpec</a> range.
binIx :: Bin s n -> Pointed (Finite n)

-- | Construct a <a>Bin</a> if you know the bin number you want to specify,
--   or if the bin is over or under the maximum.
fromIx :: Pointed (Finite n) -> Bin s n

-- | <a>Expand</a> a <a>Pointed</a> containing a <a>Finite</a> to a
--   wider-ranged <a>Finite</a>. Used for <a>binFinExt</a>
expandFin :: KnownNat n => Pointed (Finite n) -> Finite ((1 + n) + 1)

-- | The inverse of <a>expandFin</a>: "re-pack" a <a>Finite</a> back into a
--   <a>Pointed</a> containing a narrower-ranged <a>Finite</a>.
unexpandFin :: KnownNat n => Finite ((1 + n) + 1) -> Pointed (Finite n)

-- | A <tt><a>SomeBin</a> a n</tt> is <tt><a>Bin</a> s n</tt>, except with
--   the <a>BinSpec</a> s hidden. It's useful for returning out of
--   <a>withBinner</a>.
--   
--   It has useful <a>Eq</a> and <a>Ord</a> instances.
--   
--   To be able to "unify" two <a>Bin</a>s inside a <a>SomeBin</a>, use
--   <a>sameBinSpec</a> to verify that the two <a>SomeBin</a>s were created
--   with the same <a>BinSpec</a>.
data SomeBin a n
SomeBin :: Bin s n -> SomeBin a n
[getSomeBin] :: SomeBin a n -> Bin s n

-- | Verify that the two reified <a>BinSpec</a> types refer to the same
--   one, allowing you to use functions like <a>==</a> and <a>compare</a>
--   on <a>Bin</a>s that you get out of a <a>SomeBin</a>.
sameBinSpec :: forall s t n a b p. (Reifies s (BinSpec n a b), Reifies t (BinSpec n a b), KnownNat n, Eq a, Fractional b) => p s -> p t -> Maybe (s :~: t)

-- | Generate a histogram: given a container of <tt>a</tt>s, generate a
--   frequency map of how often values in a given discrete bin occurred.
--   
--   <pre>
--   xs :: [Double]
--   xs = [1..100]
--   
--   main :: IO ()
--   main = withBinner (logBS @10 5 50) $ toBin -&gt;
--       mapM_ ((b, n) -&gt; putStrLn (displayBinDouble 4 b ++ "t" ++ show n))
--     . M.toList
--     $ binFreq toBin xs
--   </pre>
--   
--   <pre>
--   (-inf .. 5.0000)        4
--   [5.0000 .. 6.2946)      2
--   [6.2946 .. 7.9245)      1
--   [7.9245 .. 9.9763)      2
--   [9.9763 .. 12.5594)     3
--   [12.5594 .. 15.8114)    3
--   [15.8114 .. 19.9054)    4
--   [19.9054 .. 25.0594)    6
--   [25.0594 .. 31.5479)    6
--   [31.5479 .. 39.7164)    8
--   [39.7164 .. 50.0000)    10
--   [50.0000 .. +inf)       51
--   </pre>
binFreq :: forall n t a s. Foldable t => Binner s n a -> t a -> Map (Bin s n) Int
instance GHC.Classes.Ord (Data.Bin.Bin s n)
instance GHC.Classes.Eq (Data.Bin.Bin s n)
instance GHC.Base.Functor Data.Bin.Pointed
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Bin.Pointed a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Bin.Pointed a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Bin.Pointed a)
instance (GHC.TypeNats.KnownNat n, GHC.Show.Show a) => GHC.Show.Show (Data.Bin.SomeBin a n)
instance (GHC.TypeNats.KnownNat n, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Bin.SomeBin a n)
instance (GHC.TypeNats.KnownNat n, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Bin.SomeBin a n)
instance (GHC.TypeNats.KnownNat n, GHC.Show.Show a, GHC.Real.Fractional b, Data.Reflection.Reifies s (Data.Bin.BinSpec n a b)) => GHC.Show.Show (Data.Bin.Bin s n)
